function cannonGiveThief(e,r){const a={0:{targetProp:"maxhp",flagIndex:0},1:{targetProp:"speed",flagIndex:1},2:{targetProp:"defense",flagIndex:2},3:{targetProp:"attack",flagIndex:3},4:{targetProp:"hp",flagIndex:4}},l=e=>{const l=a[e];if(l)for(let a=0;a<r.length;a++){const e=r[a],t=Array.isArray(e.giveSkillThief);0!==e.skill[2]&&t&&0===e.giveSkillThief[l.flagIndex]&&(e.giveSkillThief[l.flagIndex]+=1,e[l.targetProp]*=.95)}},t=e.skill[0],i=e.skill[1];return t===i?l(t):(l(t),l(i)),r}function cannonGiveEngineer(e,r){const a={KILL_COUNT_INDEX:5,SKILL_TYPE_RANGE:[0,1,2,3,4]},l={0:{targetProp:"range",flagIndex:0,addRatio:.01,maxStack:15,isGlobal:!0,judgeProp:"giveSkillEngineer",triggerType:"perKill"},1:{targetProp:"attack",flagIndex:1,addRatio:.01,maxStack:15,isGlobal:!0,judgeProp:"giveSkillEngineer",triggerType:"perKill"},2:{targetProp:"speed",flagIndex:2,addRatio:.01,maxStack:15,isGlobal:!0,judgeProp:"giveSkillEngineer",triggerType:"perKill"},3:{targetProp:"maxhp",flagIndex:3,addRatio:.01,maxStack:15,isGlobal:!0,judgeProp:"giveSkillEngineer",triggerType:"perKill"},4:{targetProp:"speed",flagIndex:4,addRatio:.1,maxStack:1,isGlobal:!0,judgeProp:"giveSkillEngineer",triggerType:"accumulateKill",killThreshold:9}};if(!e||!Array.isArray(r)||0===r.length)return console.warn("cannonGiveEngineer\uff1a\u5165\u53c2\u4e0d\u5408\u6cd5\uff0c\u8df3\u8fc7\u6280\u80fd\u5904\u7406"),r;Array.isArray(e.giveSkillEngineer)||(e.giveSkillEngineer=new Array(6).fill(0));const t=(r,a,l)=>{if(!(r&&a&&r[a.judgeProp]&&Array.isArray(r[a.judgeProp])&&r[a.judgeProp][a.flagIndex]<a.maxStack&&r!==e))return!1;switch(a.triggerType){case"perKill":return!0;case"accumulateKill":return l>=a.killThreshold;default:return!1}},i=(i,n)=>{const o=l[i];o&&a.SKILL_TYPE_RANGE.includes(i)&&o.isGlobal&&r.forEach(r=>{if(!t(r,o,n))return;r[o.judgeProp][o.flagIndex]+=1;const a=e[o.targetProp]*o.addRatio;r[o.targetProp]+=a})};e.giveSkillEngineer[a.KILL_COUNT_INDEX]+=1;const n=e.giveSkillEngineer[a.KILL_COUNT_INDEX],o=e&&e.skill&&null!=e.skill[0]?e.skill[0]:-1,c=e&&e.skill&&null!=e.skill[1]?e.skill[1]:-1;return o===c&&a.SKILL_TYPE_RANGE.includes(o)?i(o,n):(a.SKILL_TYPE_RANGE.includes(o)&&i(o,n),a.SKILL_TYPE_RANGE.includes(c)&&i(c,n)),r}function cannonGiveMercenary(e){const r={0:{effect:e=>{e.attack*=1.15}},1:{effect:e=>{e.range*=1.15}},2:{effect:e=>{e.speed*=1.15}},3:{effect:e=>{e.maxhp*=1.15,e.hp*=1.15}},4:{effect:e=>{e.prohibitThief=1}}},a=a=>{const l=r[a];l&&l.effect(e)},l=e.skill[0],t=e.skill[1];return a(l),a(t),e}function cannonGiveNurse(e,r){const a={0:{effect:(e,r)=>{e.speed+=.2*r.speed}},1:{effect:(e,r)=>{e.attack+=.15*r.attack}},2:{effect:(e,r)=>{const a=.15*r.maxhp;e.maxhp+=a,e.hp+=a}},3:{effect:e=>{e.range+=.1*e.range}},4:{effect:e=>{["goldElement","woodElement","waterElement","fireElement","soilElement"].forEach(r=>{e[r]>0&&(e[r]+=5)})}}},l=e=>Array.isArray(e.skill)&&2!==e.skill[2],t=t=>{const i=a[t];if(i)for(let a=0;a<r.length;a++){const t=r[a];l(t)&&i.effect(t,e)}},i=e.skill[0],n=e.skill[1];return t(i),t(n),r}function cannonGiveCourier(e){const r={0:{targetProp:"hp",flagIndex:0,addRatio:.04,maxStack:10},1:{targetProp:"maxhp",flagIndex:1,addRatio:.04,maxStack:10},2:{targetProp:"attack",flagIndex:2,addRatio:.02,maxStack:10},3:{targetProp:"range",flagIndex:3,addRatio:.02,maxStack:10},4:{targetProp:"speed",flagIndex:3,addRatio:.02,maxStack:10}},a=a=>{const l=r[a];l&&Array.isArray(e.giveSkillCourier)&&(e.giveSkillCourier[l.flagIndex]<l.maxStack&&(e.giveSkillCourier[l.flagIndex]+=1,e[l.targetProp]+=e[l.targetProp]*l.addRatio),e.skillNumber[0]=0)},l=e.skill[0],t=e.skill[1];return l===t?(e.skillNumber[0]+=1,e.skillNumber[0]>=5&&a(l)):(e.skillNumber[0]+=1,e.skillNumber[0]>=5&&(a(l),a(t))),e}function cannonGiveDoctor(e,r){const a={0:{effect:(e,r)=>{e.speed+=.4*r.speed}},1:{effect:(e,r)=>{e.attack+=.3*r.attack}},2:{effect:(e,r)=>{const a=.3*r.maxhp;e.maxhp+=a,e.hp+=a}},3:{effect:(e,r)=>{e.range+=.2*r.range}},4:{effect:e=>{["goldElement","woodElement","waterElement","fireElement","soilElement"].forEach(r=>{e[r]>0&&(e[r]+=10)})}}},l=(e,r)=>{if(!e.blockPlace||!r.blockPlace)return!1;const a=r.blockPlace.x-e.blockPlace.x,l=r.blockPlace.y-e.blockPlace.y;return a>=-1&&a<=1&&l>=-1&&l<=1},t=e=>Array.isArray(e.skill)&&e.skill.length>=3&&2!==e.skill[2],i=i=>{const n=a[i];if(n)for(let a=0;a<r.length;a++){const i=r[a];l(i,e)&&t(i)&&n.effect(i,e)}},n=e.skill[0],o=e.skill[1],c=n===o;return i(n),c||i(o),r}function cannonGiveCaptain(e,r){const a={0:{targetProfessions:[2,10]},1:{targetProfessions:[5,3]},2:{targetProfessions:[6,8]},3:{targetProfessions:[9,0]},4:{targetProfessions:[11,4]}},l=(e,r)=>{const a=e.skill[2];return 0===e.giveSkillCaptain&&Array.isArray(e.skill)&&e.skill.length>=3&&r.targetProfessions.includes(a)},t=t=>{const i=a[t];i&&l(r,i)&&(r.speed-=.3*e.speed,r.giveSkillCaptain+=1)},i=e.skill[0],n=e.skill[1],o=i===n;return t(i),o||t(n),r}function cannonGiveProgrammer(e,r){const a=e.skill[0],l=e.skill[1],t=(a,l)=>{for(let e=0;e<r.length;e++){const t=r[e];if(!(t.giveSkillProgrammer[a]>=10)){switch(a){case 0:t.speed+=t.speed*l;break;case 1:t.range+=t.range*l;break;case 2:t.attack+=t.attack*l;break;case 3:t.maxhp+=t.maxhp*l;break;case 4:t.hp+=t.maxhp*l,t.hp>t.maxhp&&(t.hp=t.maxhp)}t.giveSkillProgrammer[a]+=1,r[e]=t}}e.skillNumber[0]=0};return a==l?(e.skillNumber[0]+=1,e.skillNumber[0]>=5&&t(a,.02)):(e.skillNumber[0]+=1,e.skillNumber[0]>=5&&(t(a,.01),t(l,.01))),r}function cannonGiveElectrician(e,r){const a={0:{hpThreshold:.9,flagIndex:0,targetProp:"speed",reduceRatio:.1,baseProp:"speed"},1:{hpThreshold:.8,flagIndex:1,targetProp:"attack",reduceRatio:.1,baseProp:"attack"},2:{hpThreshold:.7,flagIndex:2,targetProp:"maxhp",reduceRatio:.1,baseProp:"maxhp"},3:{hpThreshold:.6,flagIndex:3,targetProp:"defense",reduceRatio:.1,baseProp:"range"},4:{hpThreshold:.2,flagIndex:4,targetProp:"speed",reduceRatio:.2,baseProp:"speed"}},l=(e,r)=>(e.maxhp>0?e.hp/e.maxhp:0)<=r.hpThreshold&&Array.isArray(e.giveSkillElectrician)&&e.giveSkillElectrician.length>=5&&0===e.giveSkillElectrician[r.flagIndex],t=(t,i)=>{const n=a[t];if(n&&l(r,n)){const a=e[n.baseProp]*n.reduceRatio*i;r[n.targetProp]-=a,r.giveSkillElectrician[n.flagIndex]+=1}},i=e.skill[0],n=e.skill[1];return i===n?t(i,2):(t(i,1),t(n,1)),r}function cannonGiveTeacher(e){const r=e.skill[0],a=e.skill[1];e.skillNumber[0]+=1;const l=(r,a)=>{switch(r){case 0:e.giveSkillTeacher[0]<5&&(e.range+=.03*e.range*a,e.giveSkillTeacher[0]+=1);break;case 1:e.giveSkillTeacher[1]<5&&(e.attack+=.03*e.attack*a,e.giveSkillTeacher[1]+=1);break;case 2:e.giveSkillTeacher[2]<5&&(e.speed+=.03*e.speed*a,e.giveSkillTeacher[2]+=1);break;case 3:e.giveSkillTeacher[3]<5&&(e.maxhp+=.03*e.maxhp*a,e.hp+=.03*e.hp,e.giveSkillTeacher[3]+=1);break;case 4:e.skillNumber[0]>=7&&0===e.skillNumber[1]&&(e.attack+=.15*e.attack*a,e.skillNumber[1]+=1)}};return r===a?l(r,2):(l(r,1),l(a,1)),e}function cannonGiveAthletes(e){const r={0:"goldElement",1:"woodElement",2:"waterElement",3:"fireElement",4:"soilElement"},a=a=>{const l=r[a];l&&e.hasOwnProperty(l)&&(e[l]+=15)},l=e.skill[0],t=e.skill[1];return l===t?a(l):(a(l),a(t)),e}function cannonGiveDriver(e,r){const a={0:{minTripRatio:.1,flagIndex:0,reduceProp:"attack",cannonProp:"attack",ratio:.2},1:{minTripRatio:.2,flagIndex:1,reduceProp:"maxhp",cannonProp:"maxhp",ratio:.2},2:{minTripRatio:.3,flagIndex:2,reduceProp:"defense",cannonProp:"range",ratio:.1},3:{minTripRatio:.4,flagIndex:3,reduceProp:"speed",cannonProp:"speed",ratio:.1},4:{minTripRatio:.8,flagIndex:4,reduceProp:"defense",cannonProp:"range",ratio:.2}},l=r.trip/r.globalLength,t=(t,i)=>{const n=a[t];n&&l>=n.minTripRatio&&0===r.giveSkillDriver[n.flagIndex]&&(r.giveSkillDriver[n.flagIndex]+=1,r[n.reduceProp]-=e[n.cannonProp]*n.ratio*i)},i=e.skill[0],n=e.skill[1];return i===n?t(i,2):(t(i,1),t(n,1)),r}